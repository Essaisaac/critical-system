theory Task
  type int
  
  type real
  
  predicate (=) 'a 'a
  
  (* use why3.BuiltIn.BuiltIn *)
  
  type bool =
    | True
    | False
  
  (* use why3.Bool.Bool *)
  
  type tuple0 =
    | Tuple0
  
  (* use why3.Tuple0.Tuple01 *)
  
  type unit = ()
  
  (* use why3.Unit.Unit *)
  
  type qtmark
  
  (* use why3.Mark.Mark *)
  
  (* use why3.Prelude.Prelude *)
  
  type ref 'a =
    | Mk_ref (contents:'a)
  
  function (!) (x:ref 'a) : 'a = contents x
  
  (* use ref.Ref *)
  
  function us__ignore 'a : ()
  
  type us_private
  
  constant us_null_ext__ : us_private
  
  type us_fixed = int
  
  (* use _gnatprove_standard_th.Main_Main *)
  
  type us_type_of_heap
  
  type us_image
  
  predicate us_ignore (x:'a) = true
  
  (* use _gnatprove_standard.Main *)
  
  constant zero : int = 0
  
  constant one : int = 1
  
  predicate (<) int int
  
  predicate (>) (x:int) (y:int) = y < x
  
  predicate (<=) (x:int) (y:int) = x < y \/ x = y
  
  function (+) int int : int
  
  function (-) int : int
  
  function (*) int int : int
  
  axiom Assoc : forall x:int, y:int, z:int. ((x + y) + z) = (x + (y + z))
  
  (* clone algebra.Assoc with type t = int, function op = (+),
    prop Assoc1 = Assoc *)
  
  axiom Unit_def_l : forall x:int. (zero + x) = x
  
  axiom Unit_def_r : forall x:int. (x + zero) = x
  
  (* clone algebra.Monoid with type t1 = int, constant unit = zero,
    function op1 = (+), prop Unit_def_r1 = Unit_def_r,
    prop Unit_def_l1 = Unit_def_l, prop Assoc2 = Assoc *)
  
  axiom Inv_def_l : forall x:int. ((- x) + x) = zero
  
  axiom Inv_def_r : forall x:int. (x + (- x)) = zero
  
  (* clone algebra.Group with type t2 = int, function inv = (-),
    constant unit1 = zero, function op2 = (+), prop Inv_def_r1 = Inv_def_r,
    prop Inv_def_l1 = Inv_def_l, prop Unit_def_r2 = Unit_def_r,
    prop Unit_def_l2 = Unit_def_l, prop Assoc3 = Assoc *)
  
  axiom Comm : forall x:int, y:int. (x + y) = (y + x)
  
  (* clone algebra.Comm with type t3 = int, function op3 = (+),
    prop Comm1 = Comm *)
  
  (* meta AC function (+) *)
  
  (* clone algebra.CommutativeGroup with type t4 = int, function inv1 = (-),
    constant unit2 = zero, function op4 = (+), prop Comm2 = Comm,
    prop Inv_def_r2 = Inv_def_r, prop Inv_def_l2 = Inv_def_l,
    prop Unit_def_r3 = Unit_def_r, prop Unit_def_l3 = Unit_def_l,
    prop Assoc4 = Assoc *)
  
  axiom Assoc5 : forall x:int, y:int, z:int. ((x * y) * z) = (x * (y * z))
  
  (* clone algebra.Assoc with type t = int, function op = (*),
    prop Assoc1 = Assoc5 *)
  
  axiom Mul_distr_l :
    forall x:int, y:int, z:int. (x * (y + z)) = ((x * y) + (x * z))
  
  axiom Mul_distr_r :
    forall x:int, y:int, z:int. ((y + z) * x) = ((y * x) + (z * x))
  
  function (-) (x:int) (y:int) : int = x + (- y)
  
  (* clone algebra.Ring with type t5 = int, function (-) = (-),
    function (*) = (*), function (-) = (-), function (+) = (+),
    constant zero1 = zero, prop Mul_distr_r1 = Mul_distr_r,
    prop Mul_distr_l1 = Mul_distr_l, prop Assoc6 = Assoc5, prop Comm3 = Comm,
    prop Inv_def_r3 = Inv_def_r, prop Inv_def_l3 = Inv_def_l,
    prop Unit_def_r4 = Unit_def_r, prop Unit_def_l4 = Unit_def_l,
    prop Assoc7 = Assoc *)
  
  axiom Comm4 : forall x:int, y:int. (x * y) = (y * x)
  
  (* clone algebra.Comm with type t3 = int, function op3 = (*),
    prop Comm1 = Comm4 *)
  
  (* meta AC function (*) *)
  
  (* clone algebra.CommutativeRing with type t6 = int, function (-) = (-),
    function (*) = (*), function (-) = (-), function (+) = (+),
    constant zero2 = zero, prop Comm5 = Comm4,
    prop Mul_distr_r2 = Mul_distr_r, prop Mul_distr_l2 = Mul_distr_l,
    prop Assoc8 = Assoc5, prop Comm6 = Comm, prop Inv_def_r4 = Inv_def_r,
    prop Inv_def_l4 = Inv_def_l, prop Unit_def_r5 = Unit_def_r,
    prop Unit_def_l5 = Unit_def_l, prop Assoc9 = Assoc *)
  
  axiom Unitary : forall x:int. (one * x) = x
  
  axiom NonTrivialRing : not zero = one
  
  (* clone algebra.UnitaryCommutativeRing with type t7 = int,
    constant one1 = one, function (-) = (-), function (*) = (*),
    function (-) = (-), function (+) = (+), constant zero3 = zero,
    prop NonTrivialRing1 = NonTrivialRing, prop Unitary1 = Unitary,
    prop Comm7 = Comm4, prop Mul_distr_r3 = Mul_distr_r,
    prop Mul_distr_l3 = Mul_distr_l, prop Assoc10 = Assoc5,
    prop Comm8 = Comm, prop Inv_def_r5 = Inv_def_r,
    prop Inv_def_l5 = Inv_def_l, prop Unit_def_r6 = Unit_def_r,
    prop Unit_def_l6 = Unit_def_l, prop Assoc11 = Assoc *)
  
  predicate (>=) (x:int) (y:int) = y <= x
  
  (* clone relations.EndoRelation with type t8 = int, predicate rel = (<=),
     *)
  
  axiom Refl : forall x:int. x <= x
  
  (* clone relations.Reflexive with type t9 = int, predicate rel1 = (<=),
    prop Refl1 = Refl *)
  
  (* clone relations.EndoRelation with type t8 = int, predicate rel = (<=),
     *)
  
  axiom Trans : forall x:int, y:int, z:int. x <= y -> y <= z -> x <= z
  
  (* clone relations.Transitive with type t10 = int, predicate rel2 = (<=),
    prop Trans1 = Trans *)
  
  (* clone relations.PreOrder with type t11 = int, predicate rel3 = (<=),
    prop Trans2 = Trans, prop Refl2 = Refl *)
  
  (* clone relations.EndoRelation with type t8 = int, predicate rel = (<=),
     *)
  
  axiom Antisymm : forall x:int, y:int. x <= y -> y <= x -> x = y
  
  (* clone relations.Antisymmetric with type t12 = int,
    predicate rel4 = (<=), prop Antisymm1 = Antisymm *)
  
  (* clone relations.PartialOrder with type t13 = int, predicate rel5 = (<=),
    prop Antisymm2 = Antisymm, prop Trans3 = Trans, prop Refl3 = Refl *)
  
  (* clone relations.EndoRelation with type t8 = int, predicate rel = (<=),
     *)
  
  axiom Total : forall x:int, y:int. x <= y \/ y <= x
  
  (* clone relations.Total with type t14 = int, predicate rel6 = (<=),
    prop Total1 = Total *)
  
  (* clone relations.TotalOrder with type t15 = int, predicate rel7 = (<=),
    prop Total2 = Total, prop Antisymm3 = Antisymm, prop Trans4 = Trans,
    prop Refl4 = Refl *)
  
  axiom ZeroLessOne : zero <= one
  
  axiom CompatOrderAdd :
    forall x:int, y:int, z:int. x <= y -> (x + z) <= (y + z)
  
  axiom CompatOrderMult :
    forall x:int, y:int, z:int. x <= y -> zero <= z -> (x * z) <= (y * z)
  
  (* clone algebra.OrderedUnitaryCommutativeRing with type t16 = int,
    predicate (>=) = (>=), predicate (<=) = (<=), constant one2 = one,
    function (-) = (-), function (*) = (*), function (-) = (-),
    function (+) = (+), constant zero4 = zero,
    prop CompatOrderMult1 = CompatOrderMult,
    prop CompatOrderAdd1 = CompatOrderAdd, prop ZeroLessOne1 = ZeroLessOne,
    prop Total3 = Total, prop Antisymm4 = Antisymm, prop Trans5 = Trans,
    prop Refl5 = Refl, prop NonTrivialRing2 = NonTrivialRing,
    prop Unitary2 = Unitary, prop Comm9 = Comm4,
    prop Mul_distr_r4 = Mul_distr_r, prop Mul_distr_l4 = Mul_distr_l,
    prop Assoc12 = Assoc5, prop Comm10 = Comm, prop Inv_def_r6 = Inv_def_r,
    prop Inv_def_l6 = Inv_def_l, prop Unit_def_r7 = Unit_def_r,
    prop Unit_def_l7 = Unit_def_l, prop Assoc13 = Assoc *)
  
  (* use int.Int *)
  
  type us_split_fields =
    | Mk___split_fields (rec__main__:us_private)
  
  type text_io_file_type =
    | Mk_text_io_file_type (us_split_fields:us_split_fields)
  
  function bool_eq (a:text_io_file_type) (b:text_io_file_type) : bool =
    if rec__main__ (us_split_fields a) = rec__main__ (us_split_fields b) then True
    else False
  
  function user_eq text_io_file_type text_io_file_type : bool
  
  constant value__size : int
  
  function object__size text_io_file_type : int
  
  axiom value__size_axiom : value__size >= 0
  
  axiom object__size_axiom : forall a:text_io_file_type. object__size a >= 0
  
  (* use Spark__text_io_file_type *)
  
  type us_split_fields1 =
    | Mk___split_fields1 (rec__main__1:us_private)
  
  type file_type =
    | Mk_file_type (us_split_fields1:us_split_fields1)
  
  function to_base (a:file_type) : text_io_file_type =
    Mk_text_io_file_type
     (Mk___split_fields (rec__main__1 (us_split_fields1 a)))
  
  function of_base (r:text_io_file_type) : file_type =
    Mk_file_type (Mk___split_fields1 (rec__main__ (us_split_fields r)))
  
  function bool_eq1 (a:file_type) (b:file_type) : bool =
    if rec__main__1 (us_split_fields1 a) = rec__main__1 (us_split_fields1 b) then True
    else False
  
  function user_eq1 file_type file_type : bool
  
  constant value__size1 : int
  
  function object__size1 file_type : int
  
  axiom value__size_axiom1 : value__size1 >= 0
  
  axiom object__size_axiom1 : forall a:file_type. object__size1 a >= 0
  
  (* use Spark__text_io__file_type *)
  
  constant attr__ATTRIBUTE_ADDRESS : int
  
  (* use Spark__text_io__standard_output *)
  
  function andb (x:bool) (y:bool) : bool =
    match x with
    | True -> y
    | False -> False
    end
  
  function orb (x:bool) (y:bool) : bool =
    match x with
    | False -> y
    | True -> True
    end
  
  type tuple2 'a 'a1 =
    | Tuple2 'a 'a1
  
  (* use why3.Tuple2.Tuple21 *)
  
  function xorb (x:bool) (y:bool) : bool =
    match (x, y) with
    | True, False -> True
    | False, True -> True
    | _, _ -> False
    end
  
  function notb (x:bool) : bool =
    match x with
    | False -> True
    | True -> False
    end
  
  function implb (x:bool) (y:bool) : bool =
    match (x, y) with
    | True, False -> False
    | _, _ -> True
    end
  
  (* use bool.Bool1 *)
  
  function ite (b:bool) (x:'a) (y:'a) : 'a =
    match b with
    | True -> x
    | False -> y
    end
  
  (* use bool.Ite *)
  
  function bool_eq2 (x:bool) (y:bool) : bool = if x = y then True else False
  
  (* use _gnatprove_standard_th.Boolean_Func *)
  
  function to_int (b:bool) : int = if b = True then 1 else 0
  
  function of_int (i:int) : bool = if i = 0 then False else True
  
  constant last : int = 1
  
  constant first : int = 0
  
  predicate in_range (x:int) = x = 0 \/ x = 1
  
  predicate dynamic_property (f:int) (l:int) (x:int) = in_range x
  
  function attr__ATTRIBUTE_IMAGE bool : us_image
  
  predicate attr__ATTRIBUTE_VALUE__pre_check us_image
  
  function attr__ATTRIBUTE_VALUE us_image : bool
  
  (* use _gnatprove_standard.Boolean *)
  
  type integer
  
  constant first1 : int = - 2147483648
  
  constant last1 : int = 2147483647
  
  predicate in_range1 (x:int) = first1 <= x /\ x <= last1
  
  function bool_eq3 int int : bool
  
  function bool_ne int int : bool
  
  function bool_lt int int : bool
  
  function bool_le int int : bool
  
  function bool_gt int int : bool
  
  function bool_ge int int : bool
  
  axiom bool_eq_axiom :
    forall x:int. forall y:int. bool_eq3 x y = True <-> x = y
  
  axiom bool_ne_axiom :
    forall x:int. forall y:int. bool_ne x y = True <-> not x = y
  
  axiom bool_lt_axiom :
    forall x:int. forall y:int. bool_lt x y = True <-> x < y
  
  axiom bool_int__le_axiom :
    forall x:int. forall y:int. bool_le x y = True <-> x <= y
  
  axiom bool_gt_axiom :
    forall x:int. forall y:int. bool_gt x y = True <-> x > y
  
  axiom bool_ge_axiom :
    forall x:int. forall y:int. bool_ge x y = True <-> x >= y
  
  (* use _gnatprove_standard_th.Integer *)
  
  (* use _gnatprove_standard.Integer1 *)
  
  type us_split = int
  
  function bool_eq4 (x:int) (y:int) : bool = if x = y then True else False
  
  function attr__ATTRIBUTE_IMAGE1 int : us_image
  
  predicate attr__ATTRIBUTE_VALUE__pre_check1 us_image
  
  function attr__ATTRIBUTE_VALUE1 us_image : int
  
  function to_rep integer : int
  
  function of_rep int : integer
  
  function user_eq2 integer integer : bool
  
  constant dummy : integer
  
  (* clone ada__model.Discrete_Base with type t17 = integer,
    type us_split1 = us_split, type rep_type = int, constant dummy1 = dummy,
    function user_eq3 = user_eq2, function of_rep1 = of_rep,
    function to_rep1 = to_rep,
    function attr__ATTRIBUTE_VALUE2 = attr__ATTRIBUTE_VALUE1,
    predicate attr__ATTRIBUTE_VALUE__pre_check2 = attr__ATTRIBUTE_VALUE__pre_check1,
    function attr__ATTRIBUTE_IMAGE2 = attr__ATTRIBUTE_IMAGE1,
    function bool_eq5 = bool_eq4,  *)
  
  axiom inversion_axiom : forall x:integer [to_rep x]. of_rep (to_rep x) = x
  
  axiom range_axiom : forall x:integer. in_range1 (to_rep x)
  
  predicate dynamic_property1 (f:int) (l:int) (x:int) = in_range1 x
  
  (* clone ada__model.Static_Discrete_Base with type t18 = integer,
    type us_split2 = us_split, type rep_type1 = int,
    predicate dynamic_property2 = dynamic_property1,
    predicate in_range2 = in_range1, constant last2 = last1,
    constant first2 = first1, constant dummy2 = dummy,
    function user_eq4 = user_eq2, function of_rep2 = of_rep,
    function to_rep2 = to_rep,
    function attr__ATTRIBUTE_VALUE3 = attr__ATTRIBUTE_VALUE1,
    predicate attr__ATTRIBUTE_VALUE__pre_check3 = attr__ATTRIBUTE_VALUE__pre_check1,
    function attr__ATTRIBUTE_IMAGE3 = attr__ATTRIBUTE_IMAGE1,
    function bool_eq6 = bool_eq4, prop range_axiom1 = range_axiom,
    prop inversion_axiom1 = inversion_axiom *)
  
  axiom coerce_axiom :
    forall x:int [to_rep (of_rep x)]. in_range1 x -> to_rep (of_rep x) = x
  
  (* clone ada__model.Static_Discrete with type t19 = integer,
    type us_split3 = us_split,
    predicate dynamic_property3 = dynamic_property1,
    predicate in_range3 = in_range1, constant last3 = last1,
    constant first3 = first1, constant dummy3 = dummy,
    function user_eq5 = user_eq2, function of_rep3 = of_rep,
    function to_rep3 = to_rep,
    function attr__ATTRIBUTE_VALUE4 = attr__ATTRIBUTE_VALUE1,
    predicate attr__ATTRIBUTE_VALUE__pre_check4 = attr__ATTRIBUTE_VALUE__pre_check1,
    function attr__ATTRIBUTE_IMAGE4 = attr__ATTRIBUTE_IMAGE1,
    function bool_eq7 = bool_eq4, prop coerce_axiom1 = coerce_axiom,
    prop range_axiom2 = range_axiom,
    prop inversion_axiom2 = inversion_axiom *)
  
  (* use Standard__integer *)
  
  type positive
  
  constant first4 : int = 1
  
  constant last4 : int = 2147483647
  
  predicate in_range4 (x:int) = first4 <= x /\ x <= last4
  
  type us_split4 = int
  
  function bool_eq8 (x:int) (y:int) : bool = if x = y then True else False
  
  function attr__ATTRIBUTE_IMAGE5 int : us_image
  
  predicate attr__ATTRIBUTE_VALUE__pre_check5 us_image
  
  function attr__ATTRIBUTE_VALUE5 us_image : int
  
  function to_rep4 positive : int
  
  function of_rep4 int : positive
  
  function user_eq6 positive positive : bool
  
  constant dummy4 : positive
  
  (* clone ada__model.Discrete_Base with type t17 = positive,
    type us_split1 = us_split4, type rep_type = int,
    constant dummy1 = dummy4, function user_eq3 = user_eq6,
    function of_rep1 = of_rep4, function to_rep1 = to_rep4,
    function attr__ATTRIBUTE_VALUE2 = attr__ATTRIBUTE_VALUE5,
    predicate attr__ATTRIBUTE_VALUE__pre_check2 = attr__ATTRIBUTE_VALUE__pre_check5,
    function attr__ATTRIBUTE_IMAGE2 = attr__ATTRIBUTE_IMAGE5,
    function bool_eq5 = bool_eq8,  *)
  
  axiom inversion_axiom3 :
    forall x:positive [to_rep4 x]. of_rep4 (to_rep4 x) = x
  
  axiom range_axiom3 : forall x:positive. in_range4 (to_rep4 x)
  
  predicate dynamic_property4 (f:int) (l:int) (x:int) = in_range4 x
  
  (* clone ada__model.Static_Discrete_Base with type t18 = positive,
    type us_split2 = us_split4, type rep_type1 = int,
    predicate dynamic_property2 = dynamic_property4,
    predicate in_range2 = in_range4, constant last2 = last4,
    constant first2 = first4, constant dummy2 = dummy4,
    function user_eq4 = user_eq6, function of_rep2 = of_rep4,
    function to_rep2 = to_rep4,
    function attr__ATTRIBUTE_VALUE3 = attr__ATTRIBUTE_VALUE5,
    predicate attr__ATTRIBUTE_VALUE__pre_check3 = attr__ATTRIBUTE_VALUE__pre_check5,
    function attr__ATTRIBUTE_IMAGE3 = attr__ATTRIBUTE_IMAGE5,
    function bool_eq6 = bool_eq8, prop range_axiom1 = range_axiom3,
    prop inversion_axiom1 = inversion_axiom3 *)
  
  axiom coerce_axiom2 :
    forall x:int [to_rep4 (of_rep4 x)].
     in_range4 x -> to_rep4 (of_rep4 x) = x
  
  (* clone ada__model.Static_Discrete with type t19 = positive,
    type us_split3 = us_split4,
    predicate dynamic_property3 = dynamic_property4,
    predicate in_range3 = in_range4, constant last3 = last4,
    constant first3 = first4, constant dummy3 = dummy4,
    function user_eq5 = user_eq6, function of_rep3 = of_rep4,
    function to_rep3 = to_rep4,
    function attr__ATTRIBUTE_VALUE4 = attr__ATTRIBUTE_VALUE5,
    predicate attr__ATTRIBUTE_VALUE__pre_check4 = attr__ATTRIBUTE_VALUE__pre_check5,
    function attr__ATTRIBUTE_IMAGE4 = attr__ATTRIBUTE_IMAGE5,
    function bool_eq7 = bool_eq8, prop coerce_axiom1 = coerce_axiom2,
    prop range_axiom2 = range_axiom3,
    prop inversion_axiom2 = inversion_axiom3 *)
  
  (* use Standard__positive *)
  
  type character
  
  constant first5 : int = 0
  
  constant last5 : int = 255
  
  predicate in_range5 (x:int) = first5 <= x /\ x <= last5
  
  type us_split5 = int
  
  function bool_eq9 (x:int) (y:int) : bool = if x = y then True else False
  
  function attr__ATTRIBUTE_IMAGE6 int : us_image
  
  predicate attr__ATTRIBUTE_VALUE__pre_check6 us_image
  
  function attr__ATTRIBUTE_VALUE6 us_image : int
  
  function to_rep5 character : int
  
  function of_rep5 int : character
  
  function user_eq7 character character : bool
  
  constant dummy5 : character
  
  (* clone ada__model.Discrete_Base with type t17 = character,
    type us_split1 = us_split5, type rep_type = int,
    constant dummy1 = dummy5, function user_eq3 = user_eq7,
    function of_rep1 = of_rep5, function to_rep1 = to_rep5,
    function attr__ATTRIBUTE_VALUE2 = attr__ATTRIBUTE_VALUE6,
    predicate attr__ATTRIBUTE_VALUE__pre_check2 = attr__ATTRIBUTE_VALUE__pre_check6,
    function attr__ATTRIBUTE_IMAGE2 = attr__ATTRIBUTE_IMAGE6,
    function bool_eq5 = bool_eq9,  *)
  
  axiom inversion_axiom4 :
    forall x:character [to_rep5 x]. of_rep5 (to_rep5 x) = x
  
  axiom range_axiom4 : forall x:character. in_range5 (to_rep5 x)
  
  predicate dynamic_property5 (f:int) (l:int) (x:int) = in_range5 x
  
  (* clone ada__model.Static_Discrete_Base with type t18 = character,
    type us_split2 = us_split5, type rep_type1 = int,
    predicate dynamic_property2 = dynamic_property5,
    predicate in_range2 = in_range5, constant last2 = last5,
    constant first2 = first5, constant dummy2 = dummy5,
    function user_eq4 = user_eq7, function of_rep2 = of_rep5,
    function to_rep2 = to_rep5,
    function attr__ATTRIBUTE_VALUE3 = attr__ATTRIBUTE_VALUE6,
    predicate attr__ATTRIBUTE_VALUE__pre_check3 = attr__ATTRIBUTE_VALUE__pre_check6,
    function attr__ATTRIBUTE_IMAGE3 = attr__ATTRIBUTE_IMAGE6,
    function bool_eq6 = bool_eq9, prop range_axiom1 = range_axiom4,
    prop inversion_axiom1 = inversion_axiom4 *)
  
  axiom coerce_axiom3 :
    forall x:int [to_rep5 (of_rep5 x)].
     in_range5 x -> to_rep5 (of_rep5 x) = x
  
  (* clone ada__model.Static_Discrete with type t19 = character,
    type us_split3 = us_split5,
    predicate dynamic_property3 = dynamic_property5,
    predicate in_range3 = in_range5, constant last3 = last5,
    constant first3 = first5, constant dummy3 = dummy5,
    function user_eq5 = user_eq7, function of_rep3 = of_rep5,
    function to_rep3 = to_rep5,
    function attr__ATTRIBUTE_VALUE4 = attr__ATTRIBUTE_VALUE6,
    predicate attr__ATTRIBUTE_VALUE__pre_check4 = attr__ATTRIBUTE_VALUE__pre_check6,
    function attr__ATTRIBUTE_IMAGE4 = attr__ATTRIBUTE_IMAGE6,
    function bool_eq7 = bool_eq9, prop coerce_axiom1 = coerce_axiom3,
    prop range_axiom2 = range_axiom4,
    prop inversion_axiom2 = inversion_axiom4 *)
  
  (* use Standard__character *)
  
  constant index_I1_one : int = 1
  
  (* clone _gnatprove_standard.Array__Index with type t20 = int,
    constant one3 = index_I1_one, function sub = (-), function add = (+),
    predicate gt = (>), predicate lt = (<), predicate le = (<=),  *)
  
  type map 'a
  
  function get (map 'a) int : 'a
  
  function set (map 'a) int 'a : map 'a
  
  axiom Select_eq :
    forall m:map 'a.
     forall i:int. forall a:'a [set m i a]. get (set m i a) i = a
  
  axiom Select_neq :
    forall m:map 'a.
     forall i:int, j:int.
      forall a:'a [get (set m i a) j| set m i a, get m j].
       not i = j -> get (set m i a) j = get m j
  
  function bool_eq10 (map 'a) int int (map 'a) int int : bool
  
  axiom T__ada_array___equal_def :
    forall a:map 'a.
     forall af:int.
      forall al:int.
       forall b:map 'a.
        forall bf:int.
         forall bl:int [bool_eq10 a af al b bf bl].
          (if af <= al then ((al - af) + index_I1_one) =
                             ((bl - bf) + index_I1_one) else bf > bl) /\
           (forall i:int [get a i].
             af <= i /\ i <= al -> get a i = get b ((bf - af) + i)) <->
           bool_eq10 a af al b bf bl = True
  
  function slide (map 'a) int int : map 'a
  
  axiom slide_eq :
    forall a:map 'a.
     forall first6:int [slide a first6 first6]. slide a first6 first6 = a
  
  axiom slide_def :
    forall a:map 'a.
     forall old_first:int.
      forall new_first:int.
       forall i:int [get (slide a old_first new_first) i].
        get (slide a old_first new_first) i =
         get a (i - (new_first - old_first))
  
  function concat (map 'a) int int (map 'a) int int : map 'a
  
  axiom concat_def :
    forall a:map 'a, b:map 'a.
     forall a_first:int, a_last:int, b_first:int, b_last:int.
      forall i:int [get (concat a a_first a_last b b_first b_last) i].
       (a_first <= i /\ i <= a_last ->
         get (concat a a_first a_last b b_first b_last) i = get a i) /\
        (i > a_last ->
          get (concat a a_first a_last b b_first b_last) i =
           get b ((i - a_last) + (b_first - index_I1_one)))
  
  function compare (map 'a) int int (map 'a) int int : int
  
  function xorb1 (map 'a) int int (map 'a) int int : map 'a
  
  function andb1 (map 'a) int int (map 'a) int int : map 'a
  
  function orb1 (map 'a) int int (map 'a) int int : map 'a
  
  function notb1 (map 'a) int int : map 'a
  
  function singleton 'a int : map 'a
  
  axiom singleton_def :
    forall v:'a.
     forall i:int [get (singleton v i) i]. get (singleton v i) i = v
  
  (* clone _gnatprove_standard.Array__1 with type map1 = map, type t21 = int,
    function singleton1 = singleton, function notb2 = notb1,
    function orb2 = orb1, function andb2 = andb1, function xorb2 = xorb1,
    function compare1 = compare, function concat1 = concat,
    function slide1 = slide, function bool_eq11 = bool_eq10,
    function set1 = set, function get1 = get, constant one4 = index_I1_one,
    function sub1 = (-), function add1 = (+), predicate gt1 = (>),
    predicate lt1 = (<), predicate le1 = (<=),
    prop singleton_def1 = singleton_def, prop concat_def1 = concat_def,
    prop slide_def1 = slide_def, prop slide_eq1 = slide_eq,
    prop T__ada_array___equal_def1 = T__ada_array___equal_def,
    prop Select_neq1 = Select_neq, prop Select_eq1 = Select_eq *)
  
  (* use Array__Int *)
  
  type component_type = character
  
  function index_1_id (x:int) : int = x
  
  type t22
  
  function first6 t22 : integer
  
  function last6 t22 : integer
  
  function mk int int : t22
  
  axiom mk_def :
    forall f:int, l:int [mk f l].
     in_range1 f ->
      in_range1 l ->
       to_rep (first6 (mk f l)) = f /\ to_rep (last6 (mk f l)) = l
  
  predicate dynamic_property6 (range_first:int) (range_last:int) (low:int)
    (high:int) =
    in_range1 low /\
     in_range1 high /\
      (low <= high ->
        dynamic_property4 range_first range_last low /\
         dynamic_property4 range_first range_last high)
  
  (* clone ada__model.Index_Type with type t23 = t22, type rep = int,
    type base = integer, predicate dynamic_property7 = dynamic_property6,
    function mk1 = mk, function last7 = last6, function first7 = first6,
    predicate index_le = (<=),
    predicate index_dynamic_property = dynamic_property4,
    predicate in_range_base = in_range1, function to_rep6 = to_rep,
    prop mk_def1 = mk_def *)
  
  type us_split6 = map character
  
  type us_t =
    | Mk___t (elts:map character) (rt:t22)
  
  function to_array (a:us_t) : map character = elts a
  
  function of_array (a:map character) (f:int) (l:int) : us_t =
    Mk___t a (mk f l)
  
  function first8 (a:us_t) : int = to_rep (first6 (rt a))
  
  function last8 (a:us_t) : int = to_rep (last6 (rt a))
  
  function length (a:us_t) : int =
    if first8 a <= last8 a then (index_1_id (last8 a) - index_1_id (first8 a)) +
                                 1 else 0
  
  predicate dynamic_property8 (range_first:int) (range_last:int) (f1:int)
    (l1:int) = dynamic_property6 range_first range_last f1 l1
  
  constant value__size2 : int
  
  function object__size2 (map character) : int
  
  axiom value__size_axiom2 : value__size2 >= 0
  
  axiom object__size_axiom2 : forall a:map character. object__size2 a >= 0
  
  function bool_eq12 (x:us_t) (y:us_t) : bool =
    bool_eq10 (elts x) (to_rep (first6 (rt x))) (to_rep (last6 (rt x)))
     (elts y) (to_rep (first6 (rt y))) (to_rep (last6 (rt y)))
  
  function user_eq8 us_t us_t : bool
  
  constant dummy6 : us_t
  
  (* clone ada__model.Unconstr_Array with type us_t1 = us_t,
    type us_split7 = us_split6, type t24 = t22, type index_rep_type = int,
    type index_base_type = integer, type map2 = map_subst,
    constant dummy7 = dummy6, function user_eq9 = user_eq8,
    function bool_eq13 = bool_eq12, function object__size3 = object__size2,
    constant value__size3 = value__size2,
    predicate dynamic_property9 = dynamic_property8,
    function length1 = length, function last9 = last8,
    function first9 = first8, function of_array1 = of_array,
    function to_array1 = to_array, function mk___t = Mk___t,
    function rt1 = rt, function elts1 = elts,
    predicate dynamic_property10 = dynamic_property6, function mk2 = mk,
    function last10 = last6, function first10 = first6,
    function array_bool_eq = bool_eq10, predicate index_rep_le = (<=),
    predicate index_dynamic_property1 = dynamic_property4,
    predicate in_range_base1 = in_range1, function rep_to_int = index_1_id,
    function to_rep7 = to_rep,
    prop object__size_axiom3 = object__size_axiom2,
    prop value__size_axiom3 = value__size_axiom2, prop mk_def2 = mk_def *)
  
  type string = us_t
  
  function to_string us_image : us_t
  
  function from_string us_t : us_image
  
  constant index_Index_one : int = 1
  
  (* clone _gnatprove_standard.Array__Index with type t20 = int,
    constant one3 = index_Index_one, function sub = (-), function add = (+),
    predicate gt = (>), predicate lt = (<), predicate le = (<=),  *)
  
  axiom compare_def :
    forall a:map character, b:map character.
     forall a_first:int, a_last:int, b_first:int, b_last:int
      [compare a a_first a_last b b_first b_last].
      (compare a a_first a_last b b_first b_last = 0 <->
        bool_eq10 a a_first a_last b b_first b_last = True) /\
       (compare a a_first a_last b b_first b_last < 0 <->
         (exists i:int, j:int.
           i <= a_last /\
            j < b_last /\
             bool_eq10 a a_first i b b_first j = True /\
              (i = a_last \/
                i < a_last /\
                 to_rep5 (get a (i + index_Index_one)) <
                  to_rep5 (get b (j + index_Index_one))))) /\
        (compare a a_first a_last b b_first b_last > 0 <->
          (exists i:int, j:int.
            i <= b_last /\
             j < a_last /\
              bool_eq10 a a_first j b b_first i = True /\
               (i = b_last \/
                 i < b_last /\
                  to_rep5 (get a (j + index_Index_one)) >
                   to_rep5 (get b (i + index_Index_one)))))
  
  (* clone ada__model.Array_Comparison_Axiom with type t25 = int,
    type map3 = map_subst1, type rep_type2 = int,
    type component_type1 = component_type, function to_rep8 = to_rep5,
    predicate rep_gt = (>), predicate rep_lt = (<),
    function bool_eq14 = bool_eq10, function compare2 = compare,
    function get2 = get, constant one5 = index_Index_one,
    function sub2 = (-), function add2 = (+), predicate gt2 = (>),
    predicate lt2 = (<), predicate le2 = (<=),
    prop compare_def1 = compare_def *)
  
  (* clone ada__model.Array_Int_Rep_Comparison_Axiom with type t26 = int,
    type map4 = map_subst1, type component_type2 = component_type,
    function to_rep9 = to_rep5, function bool_eq15 = bool_eq10,
    function compare3 = compare, function get3 = get,
    constant one6 = index_Index_one, function sub3 = (-),
    function add3 = (+), predicate gt3 = (>), predicate lt3 = (<),
    predicate le3 = (<=), prop compare_def2 = compare_def *)
  
  (* use Standard__string *)
  
  type file_status
  
  constant first11 : int = 0
  
  constant last11 : int = 10
  
  predicate in_range6 (x:int) = first11 <= x /\ x <= last11
  
  type us_split8 = int
  
  function bool_eq16 (x:int) (y:int) : bool = if x = y then True else False
  
  function attr__ATTRIBUTE_IMAGE7 int : us_image
  
  predicate attr__ATTRIBUTE_VALUE__pre_check7 us_image
  
  function attr__ATTRIBUTE_VALUE7 us_image : int
  
  function to_rep10 file_status : int
  
  function of_rep6 int : file_status
  
  function user_eq10 file_status file_status : bool
  
  constant dummy8 : file_status
  
  (* clone ada__model.Discrete_Base with type t17 = file_status,
    type us_split1 = us_split8, type rep_type = int,
    constant dummy1 = dummy8, function user_eq3 = user_eq10,
    function of_rep1 = of_rep6, function to_rep1 = to_rep10,
    function attr__ATTRIBUTE_VALUE2 = attr__ATTRIBUTE_VALUE7,
    predicate attr__ATTRIBUTE_VALUE__pre_check2 = attr__ATTRIBUTE_VALUE__pre_check7,
    function attr__ATTRIBUTE_IMAGE2 = attr__ATTRIBUTE_IMAGE7,
    function bool_eq5 = bool_eq16,  *)
  
  axiom inversion_axiom5 :
    forall x:file_status [to_rep10 x]. of_rep6 (to_rep10 x) = x
  
  axiom range_axiom5 : forall x:file_status. in_range6 (to_rep10 x)
  
  predicate dynamic_property11 (f:int) (l:int) (x:int) = in_range6 x
  
  (* clone ada__model.Static_Discrete_Base with type t18 = file_status,
    type us_split2 = us_split8, type rep_type1 = int,
    predicate dynamic_property2 = dynamic_property11,
    predicate in_range2 = in_range6, constant last2 = last11,
    constant first2 = first11, constant dummy2 = dummy8,
    function user_eq4 = user_eq10, function of_rep2 = of_rep6,
    function to_rep2 = to_rep10,
    function attr__ATTRIBUTE_VALUE3 = attr__ATTRIBUTE_VALUE7,
    predicate attr__ATTRIBUTE_VALUE__pre_check3 = attr__ATTRIBUTE_VALUE__pre_check7,
    function attr__ATTRIBUTE_IMAGE3 = attr__ATTRIBUTE_IMAGE7,
    function bool_eq6 = bool_eq16, prop range_axiom1 = range_axiom5,
    prop inversion_axiom1 = inversion_axiom5 *)
  
  axiom coerce_axiom4 :
    forall x:int [to_rep10 (of_rep6 x)].
     in_range6 x -> to_rep10 (of_rep6 x) = x
  
  (* clone ada__model.Static_Discrete with type t19 = file_status,
    type us_split3 = us_split8,
    predicate dynamic_property3 = dynamic_property11,
    predicate in_range3 = in_range6, constant last3 = last11,
    constant first3 = first11, constant dummy3 = dummy8,
    function user_eq5 = user_eq10, function of_rep3 = of_rep6,
    function to_rep3 = to_rep10,
    function attr__ATTRIBUTE_VALUE4 = attr__ATTRIBUTE_VALUE7,
    predicate attr__ATTRIBUTE_VALUE__pre_check4 = attr__ATTRIBUTE_VALUE__pre_check7,
    function attr__ATTRIBUTE_IMAGE4 = attr__ATTRIBUTE_IMAGE7,
    function bool_eq7 = bool_eq16, prop coerce_axiom1 = coerce_axiom4,
    prop range_axiom2 = range_axiom5,
    prop inversion_axiom2 = inversion_axiom5 *)
  
  (* use Spark__text_io__file_status *)
  
  constant attr__ATTRIBUTE_ADDRESS1 : int
  
  (* use Spark__text_io__standard_error *)
  
  function status file_type : int
  
  (* use Spark__text_io__status *)
  
  axiom status__post_axiom :
    forall file:file_type [status file].
     true -> (let result = status file in
      dynamic_property11 first11 last11 result)
  
  (* use Spark__text_io__status__axiom *)
  
  function is_writable file_type : bool
  
  (* use Spark__text_io__is_writable *)
  
  type file_mode
  
  constant first12 : int = 0
  
  constant last12 : int = 2
  
  predicate in_range7 (x:int) = first12 <= x /\ x <= last12
  
  type us_split9 = int
  
  function bool_eq17 (x:int) (y:int) : bool = if x = y then True else False
  
  function attr__ATTRIBUTE_IMAGE8 int : us_image
  
  predicate attr__ATTRIBUTE_VALUE__pre_check8 us_image
  
  function attr__ATTRIBUTE_VALUE8 us_image : int
  
  function to_rep11 file_mode : int
  
  function of_rep7 int : file_mode
  
  function user_eq11 file_mode file_mode : bool
  
  constant dummy9 : file_mode
  
  (* clone ada__model.Discrete_Base with type t17 = file_mode,
    type us_split1 = us_split9, type rep_type = int,
    constant dummy1 = dummy9, function user_eq3 = user_eq11,
    function of_rep1 = of_rep7, function to_rep1 = to_rep11,
    function attr__ATTRIBUTE_VALUE2 = attr__ATTRIBUTE_VALUE8,
    predicate attr__ATTRIBUTE_VALUE__pre_check2 = attr__ATTRIBUTE_VALUE__pre_check8,
    function attr__ATTRIBUTE_IMAGE2 = attr__ATTRIBUTE_IMAGE8,
    function bool_eq5 = bool_eq17,  *)
  
  axiom inversion_axiom6 :
    forall x:file_mode [to_rep11 x]. of_rep7 (to_rep11 x) = x
  
  axiom range_axiom6 : forall x:file_mode. in_range7 (to_rep11 x)
  
  predicate dynamic_property12 (f:int) (l:int) (x:int) = in_range7 x
  
  (* clone ada__model.Static_Discrete_Base with type t18 = file_mode,
    type us_split2 = us_split9, type rep_type1 = int,
    predicate dynamic_property2 = dynamic_property12,
    predicate in_range2 = in_range7, constant last2 = last12,
    constant first2 = first12, constant dummy2 = dummy9,
    function user_eq4 = user_eq11, function of_rep2 = of_rep7,
    function to_rep2 = to_rep11,
    function attr__ATTRIBUTE_VALUE3 = attr__ATTRIBUTE_VALUE8,
    predicate attr__ATTRIBUTE_VALUE__pre_check3 = attr__ATTRIBUTE_VALUE__pre_check8,
    function attr__ATTRIBUTE_IMAGE3 = attr__ATTRIBUTE_IMAGE8,
    function bool_eq6 = bool_eq17, prop range_axiom1 = range_axiom6,
    prop inversion_axiom1 = inversion_axiom6 *)
  
  axiom coerce_axiom5 :
    forall x:int [to_rep11 (of_rep7 x)].
     in_range7 x -> to_rep11 (of_rep7 x) = x
  
  (* clone ada__model.Static_Discrete with type t19 = file_mode,
    type us_split3 = us_split9,
    predicate dynamic_property3 = dynamic_property12,
    predicate in_range3 = in_range7, constant last3 = last12,
    constant first3 = first12, constant dummy3 = dummy9,
    function user_eq5 = user_eq11, function of_rep3 = of_rep7,
    function to_rep3 = to_rep11,
    function attr__ATTRIBUTE_VALUE4 = attr__ATTRIBUTE_VALUE8,
    predicate attr__ATTRIBUTE_VALUE__pre_check4 = attr__ATTRIBUTE_VALUE__pre_check8,
    function attr__ATTRIBUTE_IMAGE4 = attr__ATTRIBUTE_IMAGE8,
    function bool_eq7 = bool_eq17, prop coerce_axiom1 = coerce_axiom5,
    prop range_axiom2 = range_axiom6,
    prop inversion_axiom2 = inversion_axiom6 *)
  
  (* use Spark__text_io__file_mode *)
  
  function is_open file_type : bool
  
  (* use Spark__text_io__is_open *)
  
  function mode__2 file_type : int
  
  (* use Spark__text_io__mode__2 *)
  
  axiom is_writable__def_axiom :
    forall file:file_type [is_writable file].
     is_writable file = True <->
      is_open file = True /\ (mode__2 file = 1 \/ mode__2 file = 2)
  
  (* use Spark__text_io__is_writable__axiom *)
  
  (* use Spark__text_io__init_standard_output__axiom *)
  
  (* use Spark__text_io__init_standard_error__axiom *)
  
  type count
  
  constant first13 : int = 0
  
  constant last13 : int = 2147483647
  
  predicate in_range8 (x:int) = first13 <= x /\ x <= last13
  
  type us_split10 = int
  
  function bool_eq18 (x:int) (y:int) : bool = if x = y then True else False
  
  function attr__ATTRIBUTE_IMAGE9 int : us_image
  
  predicate attr__ATTRIBUTE_VALUE__pre_check9 us_image
  
  function attr__ATTRIBUTE_VALUE9 us_image : int
  
  function to_rep12 count : int
  
  function of_rep8 int : count
  
  function user_eq12 count count : bool
  
  constant dummy10 : count
  
  (* clone ada__model.Discrete_Base with type t17 = count,
    type us_split1 = us_split10, type rep_type = int,
    constant dummy1 = dummy10, function user_eq3 = user_eq12,
    function of_rep1 = of_rep8, function to_rep1 = to_rep12,
    function attr__ATTRIBUTE_VALUE2 = attr__ATTRIBUTE_VALUE9,
    predicate attr__ATTRIBUTE_VALUE__pre_check2 = attr__ATTRIBUTE_VALUE__pre_check9,
    function attr__ATTRIBUTE_IMAGE2 = attr__ATTRIBUTE_IMAGE9,
    function bool_eq5 = bool_eq18,  *)
  
  axiom inversion_axiom7 :
    forall x:count [to_rep12 x]. of_rep8 (to_rep12 x) = x
  
  axiom range_axiom7 : forall x:count. in_range8 (to_rep12 x)
  
  predicate dynamic_property13 (f:int) (l:int) (x:int) = in_range8 x
  
  (* clone ada__model.Static_Discrete_Base with type t18 = count,
    type us_split2 = us_split10, type rep_type1 = int,
    predicate dynamic_property2 = dynamic_property13,
    predicate in_range2 = in_range8, constant last2 = last13,
    constant first2 = first13, constant dummy2 = dummy10,
    function user_eq4 = user_eq12, function of_rep2 = of_rep8,
    function to_rep2 = to_rep12,
    function attr__ATTRIBUTE_VALUE3 = attr__ATTRIBUTE_VALUE9,
    predicate attr__ATTRIBUTE_VALUE__pre_check3 = attr__ATTRIBUTE_VALUE__pre_check9,
    function attr__ATTRIBUTE_IMAGE3 = attr__ATTRIBUTE_IMAGE9,
    function bool_eq6 = bool_eq18, prop range_axiom1 = range_axiom7,
    prop inversion_axiom1 = inversion_axiom7 *)
  
  axiom coerce_axiom6 :
    forall x:int [to_rep12 (of_rep8 x)].
     in_range8 x -> to_rep12 (of_rep8 x) = x
  
  (* clone ada__model.Static_Discrete with type t19 = count,
    type us_split3 = us_split10,
    predicate dynamic_property3 = dynamic_property13,
    predicate in_range3 = in_range8, constant last3 = last13,
    constant first3 = first13, constant dummy3 = dummy10,
    function user_eq5 = user_eq12, function of_rep3 = of_rep8,
    function to_rep3 = to_rep12,
    function attr__ATTRIBUTE_VALUE4 = attr__ATTRIBUTE_VALUE9,
    predicate attr__ATTRIBUTE_VALUE__pre_check4 = attr__ATTRIBUTE_VALUE__pre_check9,
    function attr__ATTRIBUTE_IMAGE4 = attr__ATTRIBUTE_IMAGE9,
    function bool_eq7 = bool_eq18, prop coerce_axiom1 = coerce_axiom6,
    prop range_axiom2 = range_axiom7,
    prop inversion_axiom2 = inversion_axiom7 *)
  
  (* use Spark__text_io__count *)
  
  function is_standard_output file_type : bool
  
  (* use Spark__text_io__is_standard_output *)
  
  function name file_type : us_t
  
  (* use Spark__text_io__name *)
  
  function form file_type : us_t
  
  (* use Spark__text_io__form *)
  
  function line_length__2 file_type : int
  
  (* use Spark__text_io__line_length__2 *)
  
  function page_length__2 file_type : int
  
  (* use Spark__text_io__page_length__2 *)
  
  (* use Spark__text_io__new_line__3__axiom *)
  
  (* use Spark__text_io__put__4__axiom *)
  
  function is_standard_file file_type : bool
  
  (* use Spark__text_io__is_standard_file *)
  
  (* use Spark__text_io__put_line__axiom *)
  
  (* use Integer_io__put__2__axiom *)
  
  (* use Use_int_io_1__L_1 *)
  
  constant attr__ATTRIBUTE_ADDRESS2 : int
  
  (* use Use_int_io_1__L_1__i *)
  
  type component_type3 = character
  
  constant first14 : int = 1
  
  constant last14 : int = 24
  
  type us_t2 = map character
  
  function to_array2 (a:map character) : map character = a
  
  function of_array2 (a:map character) : map character = a
  
  constant dummy11 : map character
  
  constant value__size4 : int
  
  function object__size4 (map character) : int
  
  axiom value__size_axiom4 : value__size4 >= 0
  
  axiom object__size_axiom4 : forall a:map character. object__size4 a >= 0
  
  function bool_eq19 (x:map character) (y:map character) : bool =
    bool_eq10 x first14 last14 y first14 last14
  
  function user_eq13 (map character) (map character) : bool
  
  (* clone ada__model.Constr_Array with type us_t3 = us_t2,
    type map5 = map_subst2, type index_rep_type1 = int,
    function user_eq14 = user_eq13, function bool_eq20 = bool_eq19,
    function object__size5 = object__size4,
    constant value__size5 = value__size4, constant dummy12 = dummy11,
    function of_array3 = of_array2, function to_array3 = to_array2,
    function array_bool_eq1 = bool_eq10, constant last15 = last14,
    constant first15 = first14,
    prop object__size_axiom5 = object__size_axiom4,
    prop value__size_axiom5 = value__size_axiom4 *)
  
  type t3b = map character
  
  constant index_Index_one1 : int = 1
  
  (* clone _gnatprove_standard.Array__Index with type t20 = int,
    constant one3 = index_Index_one1, function sub = (-), function add = (+),
    predicate gt = (>), predicate lt = (<), predicate le = (<=),  *)
  
  axiom compare_def3 :
    forall a:map character, b:map character.
     forall a_first:int, a_last:int, b_first:int, b_last:int
      [compare a a_first a_last b b_first b_last].
      (compare a a_first a_last b b_first b_last = 0 <->
        bool_eq10 a a_first a_last b b_first b_last = True) /\
       (compare a a_first a_last b b_first b_last < 0 <->
         (exists i:int, j:int.
           i <= a_last /\
            j < b_last /\
             bool_eq10 a a_first i b b_first j = True /\
              (i = a_last \/
                i < a_last /\
                 to_rep5 (get a (i + index_Index_one1)) <
                  to_rep5 (get b (j + index_Index_one1))))) /\
        (compare a a_first a_last b b_first b_last > 0 <->
          (exists i:int, j:int.
            i <= b_last /\
             j < a_last /\
              bool_eq10 a a_first j b b_first i = True /\
               (i = b_last \/
                 i < b_last /\
                  to_rep5 (get a (j + index_Index_one1)) >
                   to_rep5 (get b (i + index_Index_one1)))))
  
  (* clone ada__model.Array_Comparison_Axiom with type t25 = int,
    type map3 = map_subst3, type rep_type2 = int,
    type component_type1 = component_type3, function to_rep8 = to_rep5,
    predicate rep_gt = (>), predicate rep_lt = (<),
    function bool_eq14 = bool_eq10, function compare2 = compare,
    function get2 = get, constant one5 = index_Index_one1,
    function sub2 = (-), function add2 = (+), predicate gt2 = (>),
    predicate lt2 = (<), predicate le2 = (<=),
    prop compare_def1 = compare_def3 *)
  
  (* clone ada__model.Array_Int_Rep_Comparison_Axiom with type t26 = int,
    type map4 = map_subst3, type component_type2 = component_type3,
    function to_rep9 = to_rep5, function bool_eq15 = bool_eq10,
    function compare3 = compare, function get3 = get,
    constant one6 = index_Index_one1, function sub3 = (-),
    function add3 = (+), predicate gt3 = (>), predicate lt3 = (<),
    predicate le3 = (<=), prop compare_def2 = compare_def3 *)
  
  (* use Use_int_io_1__L_1__T3b *)
  
  constant temp___use_int_io_1_230 : map character
  
  (* use Temp___use_int_io_1_230 *)
  
  type component_type4 = character
  
  constant first16 : int = 1
  
  constant last16 : int = 15
  
  type us_t4 = map character
  
  function to_array4 (a:map character) : map character = a
  
  function of_array4 (a:map character) : map character = a
  
  constant dummy13 : map character
  
  constant value__size6 : int
  
  function object__size6 (map character) : int
  
  axiom value__size_axiom6 : value__size6 >= 0
  
  axiom object__size_axiom6 : forall a:map character. object__size6 a >= 0
  
  function bool_eq21 (x:map character) (y:map character) : bool =
    bool_eq10 x first16 last16 y first16 last16
  
  function user_eq15 (map character) (map character) : bool
  
  (* clone ada__model.Constr_Array with type us_t3 = us_t4,
    type map5 = map_subst4, type index_rep_type1 = int,
    function user_eq14 = user_eq15, function bool_eq20 = bool_eq21,
    function object__size5 = object__size6,
    constant value__size5 = value__size6, constant dummy12 = dummy13,
    function of_array3 = of_array4, function to_array3 = to_array4,
    function array_bool_eq1 = bool_eq10, constant last15 = last16,
    constant first15 = first16,
    prop object__size_axiom5 = object__size_axiom6,
    prop value__size_axiom5 = value__size_axiom6 *)
  
  type t2b = map character
  
  constant index_Index_one2 : int = 1
  
  (* clone _gnatprove_standard.Array__Index with type t20 = int,
    constant one3 = index_Index_one2, function sub = (-), function add = (+),
    predicate gt = (>), predicate lt = (<), predicate le = (<=),  *)
  
  axiom compare_def4 :
    forall a:map character, b:map character.
     forall a_first:int, a_last:int, b_first:int, b_last:int
      [compare a a_first a_last b b_first b_last].
      (compare a a_first a_last b b_first b_last = 0 <->
        bool_eq10 a a_first a_last b b_first b_last = True) /\
       (compare a a_first a_last b b_first b_last < 0 <->
         (exists i:int, j:int.
           i <= a_last /\
            j < b_last /\
             bool_eq10 a a_first i b b_first j = True /\
              (i = a_last \/
                i < a_last /\
                 to_rep5 (get a (i + index_Index_one2)) <
                  to_rep5 (get b (j + index_Index_one2))))) /\
        (compare a a_first a_last b b_first b_last > 0 <->
          (exists i:int, j:int.
            i <= b_last /\
             j < a_last /\
              bool_eq10 a a_first j b b_first i = True /\
               (i = b_last \/
                 i < b_last /\
                  to_rep5 (get a (j + index_Index_one2)) >
                   to_rep5 (get b (i + index_Index_one2)))))
  
  (* clone ada__model.Array_Comparison_Axiom with type t25 = int,
    type map3 = map_subst5, type rep_type2 = int,
    type component_type1 = component_type4, function to_rep8 = to_rep5,
    predicate rep_gt = (>), predicate rep_lt = (<),
    function bool_eq14 = bool_eq10, function compare2 = compare,
    function get2 = get, constant one5 = index_Index_one2,
    function sub2 = (-), function add2 = (+), predicate gt2 = (>),
    predicate lt2 = (<), predicate le2 = (<=),
    prop compare_def1 = compare_def4 *)
  
  (* clone ada__model.Array_Int_Rep_Comparison_Axiom with type t26 = int,
    type map4 = map_subst5, type component_type2 = component_type4,
    function to_rep9 = to_rep5, function bool_eq15 = bool_eq10,
    function compare3 = compare, function get3 = get,
    constant one6 = index_Index_one2, function sub3 = (-),
    function add3 = (+), predicate gt3 = (>), predicate lt3 = (<),
    predicate le3 = (<=), prop compare_def2 = compare_def4 *)
  
  (* use Use_int_io_1__L_1__T2b *)
  
  constant temp___use_int_io_1_231 : map character
  
  (* use Temp___use_int_io_1_231 *)
  
  type component_type5 = character
  
  constant first17 : int = 1
  
  constant last17 : int = 24
  
  type us_t5 = map character
  
  function to_array5 (a:map character) : map character = a
  
  function of_array5 (a:map character) : map character = a
  
  constant dummy14 : map character
  
  constant value__size7 : int
  
  function object__size7 (map character) : int
  
  axiom value__size_axiom7 : value__size7 >= 0
  
  axiom object__size_axiom7 : forall a:map character. object__size7 a >= 0
  
  function bool_eq22 (x:map character) (y:map character) : bool =
    bool_eq10 x first17 last17 y first17 last17
  
  function user_eq16 (map character) (map character) : bool
  
  (* clone ada__model.Constr_Array with type us_t3 = us_t5,
    type map5 = map_subst6, type index_rep_type1 = int,
    function user_eq14 = user_eq16, function bool_eq20 = bool_eq22,
    function object__size5 = object__size7,
    constant value__size5 = value__size7, constant dummy12 = dummy14,
    function of_array3 = of_array5, function to_array3 = to_array5,
    function array_bool_eq1 = bool_eq10, constant last15 = last17,
    constant first15 = first17,
    prop object__size_axiom5 = object__size_axiom7,
    prop value__size_axiom5 = value__size_axiom7 *)
  
  type t4b = map character
  
  constant index_Index_one3 : int = 1
  
  (* clone _gnatprove_standard.Array__Index with type t20 = int,
    constant one3 = index_Index_one3, function sub = (-), function add = (+),
    predicate gt = (>), predicate lt = (<), predicate le = (<=),  *)
  
  axiom compare_def5 :
    forall a:map character, b:map character.
     forall a_first:int, a_last:int, b_first:int, b_last:int
      [compare a a_first a_last b b_first b_last].
      (compare a a_first a_last b b_first b_last = 0 <->
        bool_eq10 a a_first a_last b b_first b_last = True) /\
       (compare a a_first a_last b b_first b_last < 0 <->
         (exists i:int, j:int.
           i <= a_last /\
            j < b_last /\
             bool_eq10 a a_first i b b_first j = True /\
              (i = a_last \/
                i < a_last /\
                 to_rep5 (get a (i + index_Index_one3)) <
                  to_rep5 (get b (j + index_Index_one3))))) /\
        (compare a a_first a_last b b_first b_last > 0 <->
          (exists i:int, j:int.
            i <= b_last /\
             j < a_last /\
              bool_eq10 a a_first j b b_first i = True /\
               (i = b_last \/
                 i < b_last /\
                  to_rep5 (get a (j + index_Index_one3)) >
                   to_rep5 (get b (i + index_Index_one3)))))
  
  (* clone ada__model.Array_Comparison_Axiom with type t25 = int,
    type map3 = map_subst7, type rep_type2 = int,
    type component_type1 = component_type5, function to_rep8 = to_rep5,
    predicate rep_gt = (>), predicate rep_lt = (<),
    function bool_eq14 = bool_eq10, function compare2 = compare,
    function get2 = get, constant one5 = index_Index_one3,
    function sub2 = (-), function add2 = (+), predicate gt2 = (>),
    predicate lt2 = (<), predicate le2 = (<=),
    prop compare_def1 = compare_def5 *)
  
  (* clone ada__model.Array_Int_Rep_Comparison_Axiom with type t26 = int,
    type map4 = map_subst7, type component_type2 = component_type5,
    function to_rep9 = to_rep5, function bool_eq15 = bool_eq10,
    function compare3 = compare, function get3 = get,
    constant one6 = index_Index_one3, function sub3 = (-),
    function add3 = (+), predicate gt3 = (>), predicate lt3 = (<),
    predicate le3 = (<=), prop compare_def2 = compare_def5 *)
  
  (* use Use_int_io_1__L_1__T4b *)
  
  constant temp___use_int_io_1_232 : map character
  
  (* use Temp___use_int_io_1_232 *)
  
  type component_type6 = character
  
  constant first18 : int = 1
  
  constant last18 : int = 24
  
  type us_t6 = map character
  
  function to_array6 (a:map character) : map character = a
  
  function of_array6 (a:map character) : map character = a
  
  constant dummy15 : map character
  
  constant value__size8 : int
  
  function object__size8 (map character) : int
  
  axiom value__size_axiom8 : value__size8 >= 0
  
  axiom object__size_axiom8 : forall a:map character. object__size8 a >= 0
  
  function bool_eq23 (x:map character) (y:map character) : bool =
    bool_eq10 x first18 last18 y first18 last18
  
  function user_eq17 (map character) (map character) : bool
  
  (* clone ada__model.Constr_Array with type us_t3 = us_t6,
    type map5 = map_subst8, type index_rep_type1 = int,
    function user_eq14 = user_eq17, function bool_eq20 = bool_eq23,
    function object__size5 = object__size8,
    constant value__size5 = value__size8, constant dummy12 = dummy15,
    function of_array3 = of_array6, function to_array3 = to_array6,
    function array_bool_eq1 = bool_eq10, constant last15 = last18,
    constant first15 = first18,
    prop object__size_axiom5 = object__size_axiom8,
    prop value__size_axiom5 = value__size_axiom8 *)
  
  type t5b = map character
  
  constant index_Index_one4 : int = 1
  
  (* clone _gnatprove_standard.Array__Index with type t20 = int,
    constant one3 = index_Index_one4, function sub = (-), function add = (+),
    predicate gt = (>), predicate lt = (<), predicate le = (<=),  *)
  
  axiom compare_def6 :
    forall a:map character, b:map character.
     forall a_first:int, a_last:int, b_first:int, b_last:int
      [compare a a_first a_last b b_first b_last].
      (compare a a_first a_last b b_first b_last = 0 <->
        bool_eq10 a a_first a_last b b_first b_last = True) /\
       (compare a a_first a_last b b_first b_last < 0 <->
         (exists i:int, j:int.
           i <= a_last /\
            j < b_last /\
             bool_eq10 a a_first i b b_first j = True /\
              (i = a_last \/
                i < a_last /\
                 to_rep5 (get a (i + index_Index_one4)) <
                  to_rep5 (get b (j + index_Index_one4))))) /\
        (compare a a_first a_last b b_first b_last > 0 <->
          (exists i:int, j:int.
            i <= b_last /\
             j < a_last /\
              bool_eq10 a a_first j b b_first i = True /\
               (i = b_last \/
                 i < b_last /\
                  to_rep5 (get a (j + index_Index_one4)) >
                   to_rep5 (get b (i + index_Index_one4)))))
  
  (* clone ada__model.Array_Comparison_Axiom with type t25 = int,
    type map3 = map_subst9, type rep_type2 = int,
    type component_type1 = component_type6, function to_rep8 = to_rep5,
    predicate rep_gt = (>), predicate rep_lt = (<),
    function bool_eq14 = bool_eq10, function compare2 = compare,
    function get2 = get, constant one5 = index_Index_one4,
    function sub2 = (-), function add2 = (+), predicate gt2 = (>),
    predicate lt2 = (<), predicate le2 = (<=),
    prop compare_def1 = compare_def6 *)
  
  (* clone ada__model.Array_Int_Rep_Comparison_Axiom with type t26 = int,
    type map4 = map_subst9, type component_type2 = component_type6,
    function to_rep9 = to_rep5, function bool_eq15 = bool_eq10,
    function compare3 = compare, function get3 = get,
    constant one6 = index_Index_one4, function sub3 = (-),
    function add3 = (+), predicate gt3 = (>), predicate lt3 = (<),
    predicate le3 = (<=), prop compare_def2 = compare_def6 *)
  
  (* use Use_int_io_1__L_1__T5b *)
  
  constant temp___use_int_io_1_233 : map character
  
  (* use Temp___use_int_io_1_233 *)
  
  (* use Standard__positive__axiom *)
  
  (* use Standard__character__axiom *)
  
  (* use Standard__string__axiom *)
  
  (* use Standard__integer__axiom *)
  
  (* use Use_int_io_1__L_1__i__axiom *)
  
  (* use Use_int_io_1__L_1__axiom *)
  
  (* use Spark__text_io_file_type__axiom *)
  
  (* use Spark__text_io__file_type__axiom *)
  
  (* use Spark__text_io__file_status__axiom *)
  
  (* use Spark__text_io__file_mode__axiom *)
  
  (* use Spark__text_io__count__axiom *)
  
  (* use Spark__text_io__standard_output__axiom *)
  
  (* use Spark__text_io__standard_error__axiom *)
  
  function is_standard_input file_type : bool
  
  (* use Spark__text_io__is_standard_input *)
  
  (* use Spark__text_io__is_standard_input__axiom *)
  
  (* use Spark__text_io__is_standard_output__axiom *)
  
  function is_standard_error file_type : bool
  
  (* use Spark__text_io__is_standard_error *)
  
  (* use Spark__text_io__is_standard_error__axiom *)
  
  axiom is_standard_file__def_axiom :
    forall file:file_type [is_standard_file file].
     is_standard_file file = True <->
      (is_standard_input file = True \/ is_standard_output file = True) \/
       is_standard_error file = True
  
  (* use Spark__text_io__is_standard_file__axiom *)
  
  (* use Spark__text_io__is_open__axiom *)
  
  axiom mode__2__post_axiom :
    forall file:file_type [mode__2 file].
     is_open file = True -> (let result = mode__2 file in
      dynamic_property12 first12 last12 result)
  
  (* use Spark__text_io__mode__2__axiom *)
  
  axiom name__post_axiom :
    forall file:file_type [name file].
     is_open file = True -> (let result = name file in
      dynamic_property8 first4 last4 (first8 result) (last8 result))
  
  (* use Spark__text_io__name__axiom *)
  
  axiom form__post_axiom :
    forall file:file_type [form file].
     is_open file = True -> (let result = form file in
      dynamic_property8 first4 last4 (first8 result) (last8 result))
  
  (* use Spark__text_io__form__axiom *)
  
  axiom line_length__2__post_axiom :
    forall file:file_type [line_length__2 file].
     is_writable file = True -> (let result = line_length__2 file in
      dynamic_property13 first13 last13 result)
  
  (* use Spark__text_io__line_length__2__axiom *)
  
  axiom page_length__2__post_axiom :
    forall file:file_type [page_length__2 file].
     is_writable file = True -> (let result = page_length__2 file in
      dynamic_property13 first13 last13 result)
  
  (* use Spark__text_io__page_length__2__axiom *)
  
  constant standard_output__split_fields : us_private
  
  axiom H :
    is_writable
     (Mk_file_type (Mk___split_fields1 standard_output__split_fields)) = True /\
     status (Mk_file_type (Mk___split_fields1 standard_output__split_fields)) =
      1
  
  constant standard_error__split_fields : us_private
  
  axiom H1 :
    is_writable
     (Mk_file_type (Mk___split_fields1 standard_error__split_fields)) = True /\
     status (Mk_file_type (Mk___split_fields1 standard_error__split_fields)) =
      1
  
  constant i : int
  
  axiom H2 : i = 1
  
  axiom H3 : 1 <= i
  
  axiom H4 : i <= 10
  
  constant i1 : int
  
  constant standard_error__split_fields1 : us_private
  
  constant standard_output__split_fields1 : us_private
  
  axiom H5 :
    is_writable
     (Mk_file_type (Mk___split_fields1 standard_error__split_fields1)) = True /\
     status (Mk_file_type (Mk___split_fields1 standard_error__split_fields1)) =
      1
  
  axiom H6 : 1 <= i1 /\ i1 <= 10
  
  constant o : int =
    status (Mk_file_type (Mk___split_fields1 standard_output__split_fields1))
  
  axiom H7 : dynamic_property11 first11 last11 o
  
  axiom H8 : not o = 1
  
  goal WP_parameter_def :
    is_writable
     (Mk_file_type (Mk___split_fields1 standard_error__split_fields1)) = True /\
     status (Mk_file_type (Mk___split_fields1 standard_error__split_fields1)) =
      1
end
